<h1 id="problem-statement">Problem Statement</h1>
<p>We are given <span class="math inline">\(1 \leq n &lt; 2^{40}\)</span>, <span class="math inline">\(0 \leq x &lt; 2^{60}\)</span>, and <span class="math inline">\(0 \leq y &lt; 2^{20}\)</span>. An array of <span class="math inline">\(n\)</span> non-negative integers is <strong>good</strong> if <span class="math inline">\(a_1 + a_2 + \dots + a_n = x\)</span> and <span class="math inline">\(a_1 | a_2 | \dots | a_n = y\)</span>. We are asked to compute the bitwise xor of all elements of all good arrays. (Formally, let the <strong>score</strong> of an array be <span class="math inline">\(a_1 \oplus \dots \oplus a_n\)</span>. We want to compute the <strong>total score</strong> (bitwise xor) of the scores of all good arrays.)</p>
<h1 id="high-level-overview">High-Level Overview</h1>
<p>This can seem like an intimidating problem. One way to get started is to write a brute force or try to notice some simplifying observations about the problem.</p>
<p>Here’s one to get started:</p>
<p>If <span class="math inline">\(n\)</span> is even, the total xor of all good arrays is <span class="math inline">\(0\)</span>.</p>
<p>There are many ways to see this that all take advantage of some symmetry of the problem. Here is one: for any good array <span class="math inline">\(A\)</span>, consider its reverse <span class="math inline">\(A&#39;\)</span>, which is also a good array. We can compute the total score by pairing up arrays and their reverse (<span class="math inline">\((\mathop{\mathrm{score}}(A) \oplus \mathop{\mathrm{score}}(A&#39;)) \oplus (\mathop{\mathrm{score}}(B) \oplus \mathop{\mathrm{score}}(B&#39;)) \oplus \dots\)</span>), since <span class="math inline">\(A\)</span> and <span class="math inline">\(A&#39;\)</span> contain the same elements, <span class="math inline">\(\mathop{\mathrm{score}}(A) \oplus \mathop{\mathrm{score}}(A&#39;) = 0\)</span>, so the total score is also <span class="math inline">\(0\)</span>. Importantly, note that we can only pair up <span class="math inline">\(A\)</span> and <span class="math inline">\(A&#39;\)</span> when <span class="math inline">\(A \neq A&#39;\)</span>, or when <span class="math inline">\(A\)</span> is not a palindrome. However, in a palindrome of even length <span class="math inline">\(n\)</span>, each element appears an even number of times, so its score it <span class="math inline">\(0\)</span> and does not contribute to the total.</p>
<p>Therefore we can assume <span class="math inline">\(n\)</span> is odd. Let <span class="math inline">\(B = \begin{bmatrix}
  b_1 &amp; b_2 &amp; \dots &amp; b_k
\end{bmatrix}\)</span> be the powers of <span class="math inline">\(2\)</span> in the binary representation of <span class="math inline">\(y\)</span>. For instance, if <span class="math inline">\(y = 13\)</span>, then <span class="math inline">\(B = \begin{bmatrix}
  1 &amp; 4 &amp; 8
\end{bmatrix}\)</span>. If <span class="math inline">\(A\)</span> is a good array, since <span class="math inline">\(a_1 | a_2 | \dots | a_n = y\)</span>, <span class="math inline">\(a_i\)</span> is a submask of <span class="math inline">\(y\)</span>. We can imagine “redistributing” the bits in <span class="math inline">\(A\)</span> to produce a new good array. More precisely, given a good array <span class="math inline">\(A\)</span>, let <span class="math inline">\(c_i\)</span> be the number of elements that have <span class="math inline">\(b_i\)</span> in their binary representation. Since <span class="math inline">\(a_1 | a_2 | \dots | a_n = y\)</span>, <span class="math inline">\(c_i \geq 1\)</span>, and since there are <span class="math inline">\(n\)</span> elements, <span class="math inline">\(c_i \leq n\)</span>. Let <span class="math inline">\(C = \begin{bmatrix} c_1 &amp; c_2 &amp; \dots &amp; c_k \end{bmatrix}^\top\)</span>. Since <span class="math inline">\(a_1 + a_2 + \dots + a_n = x\)</span>, we have <span class="math inline">\(c_1 b_1 + c_2 b_2 + \dots + c_k b_k = x\)</span>, and there are <span class="math display">\[F(C) = {n \choose c_1} {n \choose c_2} \dots {n \choose c_k}\]</span> ways to redistribute bits to obtain new good arrays. Each good array corresponds to some <span class="math inline">\(C\)</span>, and we can compute the total score by computing the scores of each of the <span class="math inline">\(F(C)\)</span> good arrays corresponding to <span class="math inline">\(C\)</span>. If <span class="math inline">\(F(C)\)</span> is even, then since each <span class="math inline">\(b_i\)</span> appears an even number of times, the score of all <span class="math inline">\(F(C)\)</span> arrays is <span class="math inline">\(0\)</span>. If <span class="math inline">\(F(C)\)</span> is odd, the score of all <span class="math inline">\(F(C)\)</span> arrays is the xor of all <span class="math inline">\(b_i\)</span>, where <span class="math inline">\(c_i\)</span> is odd.</p>
<p>By <a href="https://en.wikipedia.org/wiki/Lucas%27s_theorem">Lucas’ Theorem</a>, <span class="math inline">\({n \choose c_i}\)</span> is odd if and only if <span class="math inline">\(c_i\)</span> is a submask of <span class="math inline">\(n\)</span>. In order for <span class="math inline">\(F(C)\)</span> to be odd, all <span class="math inline">\({n \choose c_i}\)</span> must be odd, so <span class="math inline">\(c_i\)</span> is a submask of <span class="math inline">\(n\)</span> for all <span class="math inline">\(i\)</span>. Let <span class="math inline">\(D = \begin{bmatrix}
  d_1 &amp; d_2 &amp; \dots &amp; d_l
\end{bmatrix}^\top\)</span> be the powers of <span class="math inline">\(2\)</span> in the binary representation of <span class="math inline">\(n\)</span> (since <span class="math inline">\(n\)</span> is odd, let’s assume <span class="math inline">\(d_1 = 1\)</span> for notational convenience). Since <span class="math inline">\(c_i\)</span> is a submask of <span class="math inline">\(n\)</span>, we can represent <span class="math inline">\(c_i\)</span> with the row vector <span class="math inline">\(E_i = \begin{bmatrix}
  e_{i, 1} &amp; e_{i, 2} &amp; \dots &amp; e_{i, l}
\end{bmatrix}\)</span>, where <span class="math inline">\(e_{i, j} \in \{0, 1\}\)</span> and <span class="math inline">\(c_i = E_i D\)</span>. Let <span class="math inline">\(E\)</span> be the matrix of all <span class="math inline">\(E_i\)</span>, so <span class="math display">\[E = \begin{bmatrix}
  e_{1, 1} &amp; e_{1, 2} &amp; \dots &amp; e_{1, l} \\
  e_{2, 1} &amp; e_{2, 2} &amp; \dots &amp; e_{2, l} \\
    \vdots &amp; \vdots   &amp; \ddots &amp; \vdots \\
  e_{k, 1} &amp; e_{k, 2} &amp; \dots &amp; e_{k, l} \\
  \end{bmatrix}
  \text{ and } C = ED.\]</span></p>
<p>Then <span class="math display">\[x = BC = BED =
  \begin{bmatrix}
    b_1 &amp; b_2 \dots &amp; b_k
  \end{bmatrix}
  \begin{bmatrix}
  e_{1, 1} &amp; e_{1, 2} &amp; \dots &amp; e_{1, l} \\
  e_{2, 1} &amp; e_{2, 2} &amp; \dots &amp; e_{2, l} \\
    \vdots &amp; \vdots   &amp; \ddots &amp; \vdots \\
  e_{k, 1} &amp; e_{k, 2} &amp; \dots &amp; e_{k, l} \\
  \end{bmatrix}
  \begin{bmatrix}
    d_1 \\ d_2 \\ \vdots \\ d_l
  \end{bmatrix}.\]</span></p>
<p>For each choice of binary matrix <span class="math inline">\(E\)</span> such that <span class="math inline">\(BED = x\)</span>, we add <span class="math inline">\(b_i\)</span> to the xor-sum for each <span class="math inline">\(i\)</span> such that <span class="math inline">\(e_{i, 1} = 1\)</span> (i.e., <span class="math inline">\(c_i\)</span> is odd).</p>
<h2 id="inclusion-exclusion">Inclusion Exclusion</h2>
<p>Let’s compute the total score by computing the contribution of each <span class="math inline">\(b_i\)</span>. We will add <span class="math inline">\(b_i\)</span> to our total score exactly when there is an odd number of valid matrices <span class="math inline">\(E\)</span> with <span class="math inline">\(e_{i, 1} = 1\)</span>. However, recall that <span class="math inline">\(E\)</span> needs to satisfy the bitwise or condition as well: for each <span class="math inline">\(c_i\)</span>, we must have <span class="math inline">\(1 \leq c_i\)</span>, which means that for each <span class="math inline">\(i\)</span>, at least one <span class="math inline">\(e_{i, j}\)</span> in the <span class="math inline">\(i\)</span>’th row must be <span class="math inline">\(1\)</span>. The problem is that this is a difficult constraint to work with; we’ve already used this binary matrix representation to encode the constraint that each <span class="math inline">\(c_i\)</span> must be a submask of <span class="math inline">\(n\)</span>, but it’s harder to force each row to be nonzero.</p>
<p>Let’s work around this problem by relaxing this constraint, and then recovering the original answer using inclusion-exclusion over all submasks of <span class="math inline">\(y\)</span>. More precisely, suppose <span class="math inline">\(y&#39;\)</span> is a submask of <span class="math inline">\(y\)</span>. Let <span class="math inline">\(g(i, y&#39;)\)</span> be the parity of the number of matrices <span class="math inline">\(E\)</span> where <span class="math inline">\(e_{i, 1} = 1\)</span> and the <span class="math inline">\(k\)</span>’th row in <span class="math inline">\(E\)</span> is allowed to have nonzero entries only when <span class="math inline">\(d_k\)</span> is in the binary representation of <span class="math inline">\(y&#39;\)</span>. Importantly, we don’t require here that <span class="math inline">\(c_i \geq 1\)</span>. Then the parity of the number of matrices where <span class="math inline">\(e_{i, 1} = 1\)</span> and <span class="math inline">\(c_i \geq 1\)</span> is <span class="math inline">\(\bigoplus_{y&#39; \subseteq y} g(i, y&#39;)\)</span>. This is the same idea as regular inclusion-exclusion, except we don’t have to worry about signs since we only care about parity.</p>
<p>So now all we have to do is solve this relaxed problem for each <span class="math inline">\(i\)</span> and each submask <span class="math inline">\(y&#39;\)</span>. The issue is that there are <span class="math inline">\(O(y)\)</span> submasks and <span class="math inline">\(O(\log y)\)</span> powers of <span class="math inline">\(2\)</span> to handle, so we’re already up to <span class="math inline">\(O(y \log y)\)</span> complexity, and we still haven’t dealt with how to count the number of solutions to this very large subset sum problem. However, keep in mind that we are only interested in the parity of the number of solutions, and this is again where symmetry comes into play. Consider some valid matrix <span class="math inline">\(E\)</span>. For each nonzero entry <span class="math inline">\(e_{i, j}\)</span>, we can think of <span class="math inline">\(e_{i, j}\)</span> as “selecting” a pair of terms <span class="math inline">\(b_i d_j\)</span> to sum to <span class="math inline">\(x\)</span>. Instead of thinking of our solution space as all possible binary matrices <span class="math inline">\(E\)</span>, let’s think of it as multisets of terms of the form <span class="math inline">\(b_i d_j\)</span>, where we select some subset to sum to <span class="math inline">\(x\)</span>.</p>
<p><span id="lemma:2" label="lemma:2">[lemma:2]</span> Let <span class="math inline">\(T\)</span> be a multiset of powers of <span class="math inline">\(2\)</span> whose sum is <span class="math inline">\(S\)</span>. The number of ways to select a subset of <span class="math inline">\(T\)</span> to sum to <span class="math inline">\(x\)</span> is odd if and only if <span class="math inline">\(x\)</span> is a submask of <span class="math inline">\(S\)</span>.</p>
<p>Suppose we have two equal numbers in our multiset; let’s call them <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>. If we have a subset that includes <span class="math inline">\(a\)</span> but not <span class="math inline">\(b\)</span>, we can pair it up with a subset that includes <span class="math inline">\(b\)</span> but not <span class="math inline">\(a\)</span>, and these two subsets have the same sum. Thus if we have two equal numbers in our multiset, we only have to count the number of solutions where we either include both of them or ignore both of them, since by this pairing argument, the number of solutions where we include just one of them is even. However, if we are always either including or ignoring two terms equal to <span class="math inline">\(2^k\)</span>, we might as well replace it with the single term <span class="math inline">\(2^{k+1}\)</span>. More precisely, if our multiset is <span class="math inline">\(T\)</span>, there is a bijection between the subsets of multiset <span class="math inline">\(T\)</span> and the subsets of multiset <span class="math inline">\(T \setminus \{2^k, 2^k\} \cup \{2^{k+1}\}\)</span>. Note that the total sum of <span class="math inline">\(T\)</span> does not change.</p>
<p>Moreover, we can iteratively repeat this process until we have no more duplicate numbers in our multiset. At the end of this process, we have some set <span class="math inline">\(T\)</span> of unique powers of <span class="math inline">\(2\)</span>, and we can form a sum of <span class="math inline">\(x\)</span> exactly when <span class="math inline">\(x\)</span> is a submask of the sum of <span class="math inline">\(T\)</span>.</p>
<p>Let’s apply this observation to solve our subproblem. Given <span class="math inline">\(i\)</span> and a submask <span class="math inline">\(y&#39;\)</span>, our multiset <span class="math inline">\(T\)</span> is the set of terms <span class="math inline">\(\{ b_i d_j \}\)</span> (which are all powers of <span class="math inline">\(2\)</span> since <span class="math inline">\(b_i\)</span> and <span class="math inline">\(d_j\)</span> are powers of <span class="math inline">\(2\)</span>), where <span class="math inline">\(b_i\)</span> is in the binary representation of <span class="math inline">\(y&#39;\)</span>. Since <span class="math inline">\(\sum d_j = n\)</span>, <span class="math inline">\(T\)</span> has sum <span class="math inline">\(ny&#39;\)</span>. We can assume that <span class="math inline">\(e_{i, 1} = 1\)</span>, so let’s take this out of our multiset, so now our multiset is <span class="math inline">\(T&#39; = T \setminus \{b_i\}\)</span> with sum <span class="math inline">\(ny&#39; - b_i\)</span>. By our Lemma <a href="#lemma:2" data-reference-type="ref" data-reference="lemma:2">[lemma:2]</a>, we have an odd number of solutions if and only if <span class="math inline">\(x - b_i\)</span> is a submask of <span class="math inline">\(ny&#39; - b_i\)</span>.</p>
<h1 id="vandermonde-solution">Vandermonde Solution</h1>
<p>The editorial provides a shorter method of arriving at the same implementation of the solution described above using Lucas’ theorem and <a href="https://en.wikipedia.org/wiki/Vandermonde&#39;s_identity">Vandermonde’s identity</a>. Again, we’ll count the contribution of each power of <span class="math inline">\(2\)</span> in the binary representation of <span class="math inline">\(y\)</span> and use inclusion-exclusion to xor-sum over all submasks of <span class="math inline">\(y\)</span>. We wish to count the parity of the number of solutions to <span class="math display">\[a_1 + a_2 + \dots + a_n = x,\]</span> where each <span class="math inline">\(a_i\)</span> is a submask of <span class="math inline">\(y&#39;\)</span>, and <span class="math inline">\(b_i\)</span> is in the binary representation of <span class="math inline">\(a_1\)</span>. (Since <span class="math inline">\(n\)</span> is odd, we can pick an arbitrary <span class="math inline">\(a_j\)</span> to count its contribution, and since each <span class="math inline">\(a_j\)</span> provides the same contribution to the total score, the total score is equal to the contribution of a single <span class="math inline">\(a_j\)</span>.) We can assume we have already added <span class="math inline">\(b_i\)</span> to the sum, so then <span class="math inline">\(a_i\)</span> must be a submask of <span class="math inline">\(y&#39; - b_i\)</span>. Using Lucas’ theorem, we can encode these submask constraints as the parity of <span class="math display">\[{y&#39; - b_i \choose a_1} {y&#39; \choose a_2} \dots {y&#39; \choose a_n},\]</span> since this product will be odd if and only if each binomial coefficient is odd, which requires that <span class="math inline">\(a_j\)</span> is a submask of <span class="math inline">\(y&#39;\)</span> (or <span class="math inline">\(y&#39; - b_i\)</span> in the case of <span class="math inline">\(a_1\)</span>). Thus, we can count the parity of the number of solutions as <span class="math display">\[\sum_{a_1 + a_2 + \dots + a_n = x - b_i} 
  {y&#39; - b_i \choose a_1} {y&#39; \choose a_2} \dots {y&#39; \choose a_n}
  \pmod{2}.\]</span> By Vandermonde’s identity, this is equal to <span class="math display">\[{ny&#39; - b_i \choose x - b_i} \pmod{2}.\]</span></p>
